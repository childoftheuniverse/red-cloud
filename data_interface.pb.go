// Code generated by protoc-gen-go. DO NOT EDIT.
// source: data_interface.proto

package redcloud

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

//
// GetRequest formulates a request for fetching a single individual key.
type GetRequest struct {
	// Key of the row to be fetched from the database.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Name of the table which data is being extracted from.
	Table string `protobuf:"bytes,2,opt,name=table" json:"table,omitempty"`
	// Name of the column family the data is stored at.
	ColumnFamily string `protobuf:"bytes,3,opt,name=column_family,json=columnFamily" json:"column_family,omitempty"`
	// Name of the specific column being referred to.
	Column string `protobuf:"bytes,4,opt,name=column" json:"column,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (m *GetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *GetRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *GetRequest) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *GetRequest) GetColumnFamily() string {
	if m != nil {
		return m.ColumnFamily
	}
	return ""
}

func (m *GetRequest) GetColumn() string {
	if m != nil {
		return m.Column
	}
	return ""
}

//
// ColumnRange describes a range of column names to be operated on.
type ColumnRange struct {
	// Name of the first column to be returned.
	StartColumn string `protobuf:"bytes,1,opt,name=start_column,json=startColumn" json:"start_column,omitempty"`
	//
	// Name of the first column that should not be returned anymore, or an empty
	// string to operate on all columns following StartColumn.
	EndColumn string `protobuf:"bytes,2,opt,name=end_column,json=endColumn" json:"end_column,omitempty"`
}

func (m *ColumnRange) Reset()                    { *m = ColumnRange{} }
func (m *ColumnRange) String() string            { return proto.CompactTextString(m) }
func (*ColumnRange) ProtoMessage()               {}
func (*ColumnRange) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *ColumnRange) GetStartColumn() string {
	if m != nil {
		return m.StartColumn
	}
	return ""
}

func (m *ColumnRange) GetEndColumn() string {
	if m != nil {
		return m.EndColumn
	}
	return ""
}

//
// GetRangeRequest describes a request for data for a key range from a number
// (or range) of columns. All data matching the criteria will be streamed back
// to the client.
type GetRangeRequest struct {
	// Key of the first record to be returned.
	StartKey []byte `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	//
	// Key of the first record that shall no longer be returned; if empty, all
	// keys after the start key will be returned.
	EndKey []byte `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// Name of the table which the data is being extracted from.
	Table string `protobuf:"bytes,3,opt,name=table" json:"table,omitempty"`
	//
	// Name of the column family the data is stored at. Data can only be
	// requested from a single column family at a time.
	ColumnFamily string `protobuf:"bytes,4,opt,name=column_family,json=columnFamily" json:"column_family,omitempty"`
	// List of the names of all columns affected.
	Column []string `protobuf:"bytes,5,rep,name=column" json:"column,omitempty"`
	//
	// Minimum timestamp to be taken into account for returning, or 0.
	// Please note that no number of affected timestamps filtering can be done
	// on the data node.
	MinTimestamp int64 `protobuf:"varint,6,opt,name=min_timestamp,json=minTimestamp" json:"min_timestamp,omitempty"`
	// Maximum timestamp to be taken into account, or 0.
	MaxTimestamp int64 `protobuf:"varint,7,opt,name=max_timestamp,json=maxTimestamp" json:"max_timestamp,omitempty"`
	//
	// Maximum number of results which will be returned from each data node.
	// There will be no ordering of results, probably, so this is mostly a
	// sanity check mechanism to prevent excessive load. Setting this to 0
	// will disable any limits.
	MaxResults int64 `protobuf:"varint,8,opt,name=max_results,json=maxResults" json:"max_results,omitempty"`
}

func (m *GetRangeRequest) Reset()                    { *m = GetRangeRequest{} }
func (m *GetRangeRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRangeRequest) ProtoMessage()               {}
func (*GetRangeRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *GetRangeRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *GetRangeRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *GetRangeRequest) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *GetRangeRequest) GetColumnFamily() string {
	if m != nil {
		return m.ColumnFamily
	}
	return ""
}

func (m *GetRangeRequest) GetColumn() []string {
	if m != nil {
		return m.Column
	}
	return nil
}

func (m *GetRangeRequest) GetMinTimestamp() int64 {
	if m != nil {
		return m.MinTimestamp
	}
	return 0
}

func (m *GetRangeRequest) GetMaxTimestamp() int64 {
	if m != nil {
		return m.MaxTimestamp
	}
	return 0
}

func (m *GetRangeRequest) GetMaxResults() int64 {
	if m != nil {
		return m.MaxResults
	}
	return 0
}

//
// InsertRequest describes a request to insert a specific value for the specified
// key; the timestamp and TTL will be preserved.
type InsertRequest struct {
	// Key of the row which shall be updated.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Name of the table to mutate.
	Table string `protobuf:"bytes,2,opt,name=table" json:"table,omitempty"`
	// Name of the column family to mutate.
	ColumnFamily string `protobuf:"bytes,3,opt,name=column_family,json=columnFamily" json:"column_family,omitempty"`
	// Name of the column to insert.
	ColumnName string `protobuf:"bytes,4,opt,name=column_name,json=columnName" json:"column_name,omitempty"`
	// Column value to insert into the data stream.
	Column *Column `protobuf:"bytes,5,opt,name=column" json:"column,omitempty"`
}

func (m *InsertRequest) Reset()                    { *m = InsertRequest{} }
func (m *InsertRequest) String() string            { return proto.CompactTextString(m) }
func (*InsertRequest) ProtoMessage()               {}
func (*InsertRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *InsertRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *InsertRequest) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *InsertRequest) GetColumnFamily() string {
	if m != nil {
		return m.ColumnFamily
	}
	return ""
}

func (m *InsertRequest) GetColumnName() string {
	if m != nil {
		return m.ColumnName
	}
	return ""
}

func (m *InsertRequest) GetColumn() *Column {
	if m != nil {
		return m.Column
	}
	return nil
}

func init() {
	proto.RegisterType((*GetRequest)(nil), "redcloud.GetRequest")
	proto.RegisterType((*ColumnRange)(nil), "redcloud.ColumnRange")
	proto.RegisterType((*GetRangeRequest)(nil), "redcloud.GetRangeRequest")
	proto.RegisterType((*InsertRequest)(nil), "redcloud.InsertRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DataNodeService service

type DataNodeServiceClient interface {
	//
	// Request an individual data cell from the database. If multiple versions of
	// the cell exist, only the latest version will be returned.
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*Column, error)
	//
	// Request a range of data from the database. This will return all matching
	// versions of all matching data on the database.
	GetRange(ctx context.Context, in *GetRangeRequest, opts ...grpc.CallOption) (DataNodeService_GetRangeClient, error)
	// Set a very specific data cell to the specified value.
	Insert(ctx context.Context, in *InsertRequest, opts ...grpc.CallOption) (*Empty, error)
}

type dataNodeServiceClient struct {
	cc *grpc.ClientConn
}

func NewDataNodeServiceClient(cc *grpc.ClientConn) DataNodeServiceClient {
	return &dataNodeServiceClient{cc}
}

func (c *dataNodeServiceClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*Column, error) {
	out := new(Column)
	err := grpc.Invoke(ctx, "/redcloud.DataNodeService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeServiceClient) GetRange(ctx context.Context, in *GetRangeRequest, opts ...grpc.CallOption) (DataNodeService_GetRangeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataNodeService_serviceDesc.Streams[0], c.cc, "/redcloud.DataNodeService/GetRange", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataNodeServiceGetRangeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataNodeService_GetRangeClient interface {
	Recv() (*ColumnSet, error)
	grpc.ClientStream
}

type dataNodeServiceGetRangeClient struct {
	grpc.ClientStream
}

func (x *dataNodeServiceGetRangeClient) Recv() (*ColumnSet, error) {
	m := new(ColumnSet)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataNodeServiceClient) Insert(ctx context.Context, in *InsertRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/redcloud.DataNodeService/Insert", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DataNodeService service

type DataNodeServiceServer interface {
	//
	// Request an individual data cell from the database. If multiple versions of
	// the cell exist, only the latest version will be returned.
	Get(context.Context, *GetRequest) (*Column, error)
	//
	// Request a range of data from the database. This will return all matching
	// versions of all matching data on the database.
	GetRange(*GetRangeRequest, DataNodeService_GetRangeServer) error
	// Set a very specific data cell to the specified value.
	Insert(context.Context, *InsertRequest) (*Empty, error)
}

func RegisterDataNodeServiceServer(s *grpc.Server, srv DataNodeServiceServer) {
	s.RegisterService(&_DataNodeService_serviceDesc, srv)
}

func _DataNodeService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redcloud.DataNodeService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServiceServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNodeService_GetRange_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataNodeServiceServer).GetRange(m, &dataNodeServiceGetRangeServer{stream})
}

type DataNodeService_GetRangeServer interface {
	Send(*ColumnSet) error
	grpc.ServerStream
}

type dataNodeServiceGetRangeServer struct {
	grpc.ServerStream
}

func (x *dataNodeServiceGetRangeServer) Send(m *ColumnSet) error {
	return x.ServerStream.SendMsg(m)
}

func _DataNodeService_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServiceServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redcloud.DataNodeService/Insert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServiceServer).Insert(ctx, req.(*InsertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DataNodeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "redcloud.DataNodeService",
	HandlerType: (*DataNodeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _DataNodeService_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _DataNodeService_Insert_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetRange",
			Handler:       _DataNodeService_GetRange_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "data_interface.proto",
}

func init() { proto.RegisterFile("data_interface.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 426 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x93, 0xdf, 0x6e, 0x94, 0x40,
	0x14, 0xc6, 0x77, 0x96, 0x96, 0xee, 0x1e, 0x68, 0xb6, 0x19, 0x37, 0x16, 0x31, 0xa6, 0x88, 0x37,
	0x5c, 0xad, 0xa6, 0x7a, 0xed, 0x8d, 0x7f, 0x1a, 0xd3, 0xa4, 0x26, 0xd4, 0x7b, 0x32, 0x85, 0x53,
	0x43, 0x64, 0x06, 0x0a, 0x07, 0xb3, 0x3c, 0x80, 0xcf, 0xe2, 0x2b, 0xf8, 0x78, 0x86, 0x19, 0x08,
	0x54, 0x93, 0xde, 0xf5, 0x6e, 0xe6, 0xfb, 0x7e, 0xe7, 0x84, 0xef, 0xcc, 0x01, 0xb6, 0x99, 0x20,
	0x91, 0xe4, 0x8a, 0xb0, 0xbe, 0x15, 0x29, 0xee, 0xaa, 0xba, 0xa4, 0x92, 0xaf, 0x6a, 0xcc, 0xd2,
	0xa2, 0x6c, 0x33, 0xdf, 0xa1, 0xae, 0xc2, 0xc6, 0xc8, 0xe1, 0x1d, 0xc0, 0x05, 0x52, 0x8c, 0x77,
	0x2d, 0x36, 0xc4, 0x4f, 0xc0, 0xfa, 0x81, 0x9d, 0xc7, 0x02, 0x16, 0xb9, 0x71, 0x7f, 0xe4, 0x5b,
	0x38, 0x24, 0x71, 0x53, 0xa0, 0xb7, 0x0c, 0x58, 0xb4, 0x8e, 0xcd, 0x85, 0xbf, 0x82, 0xe3, 0xb4,
	0x2c, 0x5a, 0xa9, 0x92, 0x5b, 0x21, 0xf3, 0xa2, 0xf3, 0x2c, 0xed, 0xba, 0x46, 0xfc, 0xac, 0x35,
	0xfe, 0x14, 0x6c, 0x73, 0xf7, 0x0e, 0xb4, 0x3b, 0xdc, 0xc2, 0xaf, 0xe0, 0x7c, 0xd0, 0xa7, 0x58,
	0xa8, 0xef, 0xc8, 0x5f, 0x82, 0xdb, 0x90, 0xa8, 0x29, 0x19, 0x60, 0xa6, 0x61, 0x47, 0x6b, 0x86,
	0xe3, 0x2f, 0x00, 0x50, 0x65, 0x23, 0x60, 0xbe, 0x64, 0x8d, 0x2a, 0x33, 0x76, 0xf8, 0x6b, 0x09,
	0x9b, 0x3e, 0x44, 0xdf, 0x6e, 0x4c, 0xf2, 0x1c, 0xd6, 0xa6, 0xeb, 0x94, 0x67, 0xa5, 0x85, 0x4b,
	0xec, 0xf8, 0x29, 0x1c, 0xf5, 0xfd, 0x7a, 0x6b, 0xa9, 0x2d, 0x1b, 0x55, 0x76, 0x39, 0x4f, 0x6b,
	0x3d, 0x98, 0xf6, 0xe0, 0xc1, 0xb4, 0x87, 0x81, 0x35, 0xa5, 0xed, 0x8b, 0x65, 0xae, 0x12, 0xca,
	0x25, 0x36, 0x24, 0x64, 0xe5, 0xd9, 0x01, 0x8b, 0xac, 0xd8, 0x95, 0xb9, 0xfa, 0x36, 0x6a, 0x1a,
	0x12, 0xfb, 0x19, 0x74, 0x34, 0x40, 0x62, 0x3f, 0x41, 0x67, 0xe0, 0xf4, 0x50, 0x8d, 0x4d, 0x5b,
	0x50, 0xe3, 0xad, 0x34, 0x02, 0x52, 0xec, 0x63, 0xa3, 0x84, 0xbf, 0x19, 0x1c, 0x7f, 0x51, 0x0d,
	0xd6, 0x8f, 0xf3, 0x9e, 0x67, 0xe0, 0x0c, 0x90, 0x12, 0x12, 0x87, 0x21, 0x80, 0x91, 0xae, 0x84,
	0x44, 0x1e, 0xcd, 0x46, 0xc0, 0x22, 0xe7, 0xfc, 0x64, 0x37, 0xee, 0xdc, 0x6e, 0x78, 0xf0, 0xc1,
	0x3f, 0xff, 0xc3, 0x60, 0xf3, 0x51, 0x90, 0xb8, 0x2a, 0x33, 0xbc, 0xc6, 0xfa, 0x67, 0x9e, 0x22,
	0x7f, 0x0d, 0xd6, 0x05, 0x12, 0xdf, 0x4e, 0x45, 0xd3, 0x62, 0xfa, 0xff, 0xb5, 0x0a, 0x17, 0xfc,
	0x3d, 0xac, 0xc6, 0x57, 0xe7, 0xcf, 0xee, 0x57, 0xcd, 0x36, 0xc1, 0x7f, 0xf2, 0x6f, 0xe9, 0x35,
	0x52, 0xb8, 0x78, 0xc3, 0xf8, 0x3b, 0xb0, 0xcd, 0xb4, 0xf8, 0xe9, 0x84, 0xdc, 0x9b, 0x9f, 0xbf,
	0x99, 0x8c, 0x4f, 0xb2, 0xa2, 0x2e, 0x5c, 0xdc, 0xd8, 0xfa, 0xbf, 0x79, 0xfb, 0x37, 0x00, 0x00,
	0xff, 0xff, 0xb2, 0xc4, 0xee, 0xc3, 0x66, 0x03, 0x00, 0x00,
}
