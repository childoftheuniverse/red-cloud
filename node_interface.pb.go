// Code generated by protoc-gen-go. DO NOT EDIT.
// source: node_interface.proto

package redcloud

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

//
// RangeServingRequest describes a request to a data node to start serving a
// given range of a given table.
type RangeServingRequest struct {
	// table is the name of the table which is supposed to be loaded.
	Table string `protobuf:"bytes,1,opt,name=table" json:"table,omitempty"`
	//
	// start_key is the first valid key which is covered by the range which is
	// being loaded.
	StartKey []byte `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	//
	// end_key is the first key which is no longer covered by the range which is
	// being loaded. If this is empty, it represents the end of the table.
	EndKey []byte `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// Relevant paths for all sstables which should be loaded.
	Paths []*SSTablePathDescription `protobuf:"bytes,4,rep,name=paths" json:"paths,omitempty"`
}

func (m *RangeServingRequest) Reset()                    { *m = RangeServingRequest{} }
func (m *RangeServingRequest) String() string            { return proto.CompactTextString(m) }
func (*RangeServingRequest) ProtoMessage()               {}
func (*RangeServingRequest) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *RangeServingRequest) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *RangeServingRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *RangeServingRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *RangeServingRequest) GetPaths() []*SSTablePathDescription {
	if m != nil {
		return m.Paths
	}
	return nil
}

//
// RangeReleaseRequest describes a request to a data node to stop serving a given
// range of a given table.
type RangeReleaseRequest struct {
	// table is the name of the table whose data is supposed to be unloaded.
	Table string `protobuf:"bytes,1,opt,name=table" json:"table,omitempty"`
	//
	// start_key is the first valid key which is covered by the range which is
	// being loaded.
	StartKey []byte `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	//
	// end_key is the first key which is no longer covered by the range which is
	// being loaded. If this is empty, it represents the end of the table.
	EndKey []byte `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
}

func (m *RangeReleaseRequest) Reset()                    { *m = RangeReleaseRequest{} }
func (m *RangeReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*RangeReleaseRequest) ProtoMessage()               {}
func (*RangeReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

func (m *RangeReleaseRequest) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *RangeReleaseRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *RangeReleaseRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

//
// RangeReleaseResponse is sent in response to a RangeReleaseRequest and
// describes the sstables and journals of the unloaded tablet(s).
type RangeReleaseResponse struct {
	// Relevant paths for all sstables which have been unloaded.
	Paths []*SSTablePathDescription `protobuf:"bytes,1,rep,name=paths" json:"paths,omitempty"`
}

func (m *RangeReleaseResponse) Reset()                    { *m = RangeReleaseResponse{} }
func (m *RangeReleaseResponse) String() string            { return proto.CompactTextString(m) }
func (*RangeReleaseResponse) ProtoMessage()               {}
func (*RangeReleaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{2} }

func (m *RangeReleaseResponse) GetPaths() []*SSTablePathDescription {
	if m != nil {
		return m.Paths
	}
	return nil
}

//
// ServerStatus contains detailed information about the server load etc.
type ServerStatus struct {
	// Number of currently allocated bytes of heap memory.
	HeapSize uint64 `protobuf:"varint,1,opt,name=heap_size,json=heapSize" json:"heap_size,omitempty"`
	// Status port for looking at the web interface.
	StatusPort uint32 `protobuf:"varint,2,opt,name=status_port,json=statusPort" json:"status_port,omitempty"`
}

func (m *ServerStatus) Reset()                    { *m = ServerStatus{} }
func (m *ServerStatus) String() string            { return proto.CompactTextString(m) }
func (*ServerStatus) ProtoMessage()               {}
func (*ServerStatus) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{3} }

func (m *ServerStatus) GetHeapSize() uint64 {
	if m != nil {
		return m.HeapSize
	}
	return 0
}

func (m *ServerStatus) GetStatusPort() uint32 {
	if m != nil {
		return m.StatusPort
	}
	return 0
}

func init() {
	proto.RegisterType((*RangeServingRequest)(nil), "redcloud.RangeServingRequest")
	proto.RegisterType((*RangeReleaseRequest)(nil), "redcloud.RangeReleaseRequest")
	proto.RegisterType((*RangeReleaseResponse)(nil), "redcloud.RangeReleaseResponse")
	proto.RegisterType((*ServerStatus)(nil), "redcloud.ServerStatus")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DataNodeMetadataService service

type DataNodeMetadataServiceClient interface {
	//
	// ServeRange requests to start serving a specific range of the table. May
	// fail, but otherwise it is assumed that the table/range will be served
	// from this node in the future.
	ServeRange(ctx context.Context, in *RangeServingRequest, opts ...grpc.CallOption) (*Empty, error)
	//
	// ReleaseRange requests to stop serving a specific range of a table and to
	// return pointers to all files associated with the range at the time
	// serving has stopped.
	ReleaseRange(ctx context.Context, in *RangeReleaseRequest, opts ...grpc.CallOption) (*RangeReleaseResponse, error)
	//
	// GetServerStatus determines and returns some information about the status
	// of the server.
	GetServerStatus(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServerStatus, error)
	//
	// Ping provides simple ping functionality to check node availability.
	Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type dataNodeMetadataServiceClient struct {
	cc *grpc.ClientConn
}

func NewDataNodeMetadataServiceClient(cc *grpc.ClientConn) DataNodeMetadataServiceClient {
	return &dataNodeMetadataServiceClient{cc}
}

func (c *dataNodeMetadataServiceClient) ServeRange(ctx context.Context, in *RangeServingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/redcloud.DataNodeMetadataService/ServeRange", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeMetadataServiceClient) ReleaseRange(ctx context.Context, in *RangeReleaseRequest, opts ...grpc.CallOption) (*RangeReleaseResponse, error) {
	out := new(RangeReleaseResponse)
	err := grpc.Invoke(ctx, "/redcloud.DataNodeMetadataService/ReleaseRange", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeMetadataServiceClient) GetServerStatus(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServerStatus, error) {
	out := new(ServerStatus)
	err := grpc.Invoke(ctx, "/redcloud.DataNodeMetadataService/GetServerStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeMetadataServiceClient) Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/redcloud.DataNodeMetadataService/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DataNodeMetadataService service

type DataNodeMetadataServiceServer interface {
	//
	// ServeRange requests to start serving a specific range of the table. May
	// fail, but otherwise it is assumed that the table/range will be served
	// from this node in the future.
	ServeRange(context.Context, *RangeServingRequest) (*Empty, error)
	//
	// ReleaseRange requests to stop serving a specific range of a table and to
	// return pointers to all files associated with the range at the time
	// serving has stopped.
	ReleaseRange(context.Context, *RangeReleaseRequest) (*RangeReleaseResponse, error)
	//
	// GetServerStatus determines and returns some information about the status
	// of the server.
	GetServerStatus(context.Context, *Empty) (*ServerStatus, error)
	//
	// Ping provides simple ping functionality to check node availability.
	Ping(context.Context, *Empty) (*Empty, error)
}

func RegisterDataNodeMetadataServiceServer(s *grpc.Server, srv DataNodeMetadataServiceServer) {
	s.RegisterService(&_DataNodeMetadataService_serviceDesc, srv)
}

func _DataNodeMetadataService_ServeRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RangeServingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeMetadataServiceServer).ServeRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redcloud.DataNodeMetadataService/ServeRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeMetadataServiceServer).ServeRange(ctx, req.(*RangeServingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNodeMetadataService_ReleaseRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RangeReleaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeMetadataServiceServer).ReleaseRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redcloud.DataNodeMetadataService/ReleaseRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeMetadataServiceServer).ReleaseRange(ctx, req.(*RangeReleaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNodeMetadataService_GetServerStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeMetadataServiceServer).GetServerStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redcloud.DataNodeMetadataService/GetServerStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeMetadataServiceServer).GetServerStatus(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNodeMetadataService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeMetadataServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/redcloud.DataNodeMetadataService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeMetadataServiceServer).Ping(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _DataNodeMetadataService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "redcloud.DataNodeMetadataService",
	HandlerType: (*DataNodeMetadataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ServeRange",
			Handler:    _DataNodeMetadataService_ServeRange_Handler,
		},
		{
			MethodName: "ReleaseRange",
			Handler:    _DataNodeMetadataService_ReleaseRange_Handler,
		},
		{
			MethodName: "GetServerStatus",
			Handler:    _DataNodeMetadataService_GetServerStatus_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _DataNodeMetadataService_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "node_interface.proto",
}

func init() { proto.RegisterFile("node_interface.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 374 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x92, 0xcf, 0x8e, 0x12, 0x41,
	0x10, 0xc6, 0x19, 0xfe, 0x09, 0x05, 0x4a, 0xd2, 0x12, 0x21, 0x63, 0xd4, 0xc9, 0x9c, 0x88, 0x07,
	0x0e, 0x98, 0x78, 0x32, 0x9e, 0x30, 0x1e, 0x54, 0x24, 0x3d, 0xde, 0x27, 0xcd, 0x4c, 0x09, 0x13,
	0xa1, 0xbb, 0xed, 0x2e, 0x36, 0x19, 0x9e, 0x63, 0x2f, 0xfb, 0xb6, 0x9b, 0xe9, 0x81, 0x00, 0x0b,
	0x7b, 0xd8, 0xc3, 0x1e, 0xab, 0xbe, 0xea, 0xaa, 0x5f, 0x7d, 0xd5, 0xd0, 0x97, 0x2a, 0xc5, 0x38,
	0x93, 0x84, 0xe6, 0xaf, 0x48, 0x70, 0xac, 0x8d, 0x22, 0xc5, 0x5a, 0x06, 0xd3, 0x64, 0xad, 0xb6,
	0xa9, 0xff, 0x6a, 0x83, 0x24, 0x52, 0x41, 0xa2, 0x54, 0xfc, 0x0e, 0xe5, 0x1a, 0x6d, 0x19, 0x84,
	0x77, 0x1e, 0xbc, 0xe6, 0x42, 0x2e, 0x31, 0x42, 0x73, 0x93, 0xc9, 0x25, 0xc7, 0xff, 0x5b, 0xb4,
	0xc4, 0xfa, 0xd0, 0x20, 0xb1, 0x58, 0xe3, 0xd0, 0x0b, 0xbc, 0x51, 0x9b, 0x97, 0x01, 0x7b, 0x0b,
	0x6d, 0x4b, 0xc2, 0x50, 0xfc, 0x0f, 0xf3, 0x61, 0x35, 0xf0, 0x46, 0x5d, 0xde, 0x72, 0x89, 0x1f,
	0x98, 0xb3, 0x01, 0xbc, 0x40, 0x99, 0x3a, 0xa9, 0xe6, 0xa4, 0x26, 0xca, 0xb4, 0x10, 0x3e, 0x43,
	0x43, 0x0b, 0x5a, 0xd9, 0x61, 0x3d, 0xa8, 0x8d, 0x3a, 0x93, 0x60, 0x7c, 0x40, 0x1b, 0x47, 0xd1,
	0x9f, 0xa2, 0xef, 0x5c, 0xd0, 0x6a, 0x8a, 0x36, 0x31, 0x99, 0xa6, 0x4c, 0x49, 0x5e, 0x96, 0x87,
	0x62, 0x8f, 0xc6, 0x71, 0x8d, 0xc2, 0xe2, 0x33, 0xa0, 0x85, 0x33, 0xe8, 0x9f, 0x8f, 0xb0, 0x5a,
	0x49, 0x8b, 0x47, 0x64, 0xef, 0x69, 0xc8, 0x3f, 0xa1, 0x5b, 0x18, 0x89, 0x26, 0x22, 0x41, 0x5b,
	0x5b, 0x50, 0xad, 0x50, 0xe8, 0xd8, 0x66, 0xbb, 0x92, 0xb7, 0xce, 0x5b, 0x45, 0x22, 0xca, 0x76,
	0xc8, 0x3e, 0x40, 0xc7, 0xba, 0xb2, 0x58, 0x2b, 0x43, 0x0e, 0xfa, 0x25, 0x87, 0x32, 0x35, 0x57,
	0x86, 0x26, 0xb7, 0x55, 0x18, 0x4c, 0x05, 0x89, 0x99, 0x4a, 0xf1, 0xd7, 0xfe, 0x88, 0xee, 0x4e,
	0x09, 0xb2, 0xaf, 0x00, 0x6e, 0x92, 0xc3, 0x67, 0xef, 0x8e, 0x80, 0x57, 0xae, 0xe9, 0xf7, 0x8e,
	0xf2, 0xb7, 0x8d, 0xa6, 0x3c, 0xac, 0xb0, 0xdf, 0xd0, 0x3d, 0x2c, 0x7d, 0xb5, 0xc3, 0xb9, 0xe9,
	0xfe, 0xfb, 0xc7, 0xe4, 0xd2, 0xb0, 0xb0, 0xc2, 0xbe, 0x40, 0xef, 0x3b, 0xd2, 0xd9, 0xf6, 0x0f,
	0xc7, 0xfa, 0x6f, 0x4e, 0x7c, 0x3c, 0x29, 0x0c, 0x2b, 0xec, 0x23, 0xd4, 0xe7, 0x99, 0x5c, 0x5e,
	0x3e, 0xb9, 0x44, 0x5f, 0x34, 0xdd, 0xd7, 0xfd, 0x74, 0x1f, 0x00, 0x00, 0xff, 0xff, 0x92, 0xa6,
	0xee, 0x06, 0xf9, 0x02, 0x00, 0x00,
}
