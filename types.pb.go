// Code generated by protoc-gen-go. DO NOT EDIT.
// source: types.proto

package redcloud

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Column_ColumnContentType int32

const (
	Column_DATA      Column_ColumnContentType = 0
	Column_TOMBSTONE Column_ColumnContentType = 1
)

var Column_ColumnContentType_name = map[int32]string{
	0: "DATA",
	1: "TOMBSTONE",
}
var Column_ColumnContentType_value = map[string]int32{
	"DATA":      0,
	"TOMBSTONE": 1,
}

func (x Column_ColumnContentType) String() string {
	return proto.EnumName(Column_ColumnContentType_name, int32(x))
}
func (Column_ColumnContentType) EnumDescriptor() ([]byte, []int) { return fileDescriptor4, []int{1, 0} }

//
// Empty is an empty message. There's a similar definition in the protocol buffer
// base, but that doesn't seem to work with all protobuf compilers, so we have
// our own.
type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

//
// Column contains information about data contained within a column.
type Column struct {
	//
	// Type of the data contained in the column. In journals and minor sstables,
	// this might be set to TOMBSTONE to represent that data in the column has
	// been deleted.
	Type Column_ColumnContentType `protobuf:"varint,1,opt,name=type,enum=redcloud.Column_ColumnContentType" json:"type,omitempty"`
	//
	// timestamp describes the exact point in time, encoded as milliseconds,
	// when the datum has been written. This will be used both for expiry (see
	// ttl) and to determine the most current datum in the column.
	//
	// Nonetheless, this field is filled in by the client because red-cloud
	// can't claim to know where the data came from.
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	//
	// ttl describes the number of milliseconds this datum will be considered
	// valid. A compaction running after timestamp+ttl will discard this datum.
	// A ttl of 0 describes permanent data which will never expire.
	Ttl int64 `protobuf:"varint,3,opt,name=ttl" json:"ttl,omitempty"`
	// content contains the data actually written to the column.
	Content []byte `protobuf:"bytes,4,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *Column) Reset()                    { *m = Column{} }
func (m *Column) String() string            { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()               {}
func (*Column) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{1} }

func (m *Column) GetType() Column_ColumnContentType {
	if m != nil {
		return m.Type
	}
	return Column_DATA
}

func (m *Column) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Column) GetTtl() int64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *Column) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

//
// ColumnSet is a list of data records for a single column within a single row.
type ColumnSet struct {
	// name contains the name of the column being represented.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	//
	// A ColumnSet consists of a number of Columns. They represent different
	// versions of the data contained in the column.
	Column []*Column `protobuf:"bytes,2,rep,name=column" json:"column,omitempty"`
}

func (m *ColumnSet) Reset()                    { *m = ColumnSet{} }
func (m *ColumnSet) String() string            { return proto.CompactTextString(m) }
func (*ColumnSet) ProtoMessage()               {}
func (*ColumnSet) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{2} }

func (m *ColumnSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ColumnSet) GetColumn() []*Column {
	if m != nil {
		return m.Column
	}
	return nil
}

//
// ColumnFamily contains all ColumnSet objects associated with a single row
// which belong to a single column family.
type ColumnFamily struct {
	// Row key to identify the row this ColumnFamily pertains to.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Many ColumnSets make a ColumnFamily.
	ColumnSet []*ColumnSet `protobuf:"bytes,2,rep,name=column_set,json=columnSet" json:"column_set,omitempty"`
}

func (m *ColumnFamily) Reset()                    { *m = ColumnFamily{} }
func (m *ColumnFamily) String() string            { return proto.CompactTextString(m) }
func (*ColumnFamily) ProtoMessage()               {}
func (*ColumnFamily) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{3} }

func (m *ColumnFamily) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *ColumnFamily) GetColumnSet() []*ColumnSet {
	if m != nil {
		return m.ColumnSet
	}
	return nil
}

func init() {
	proto.RegisterType((*Empty)(nil), "redcloud.Empty")
	proto.RegisterType((*Column)(nil), "redcloud.Column")
	proto.RegisterType((*ColumnSet)(nil), "redcloud.ColumnSet")
	proto.RegisterType((*ColumnFamily)(nil), "redcloud.ColumnFamily")
	proto.RegisterEnum("redcloud.Column_ColumnContentType", Column_ColumnContentType_name, Column_ColumnContentType_value)
}

func init() { proto.RegisterFile("types.proto", fileDescriptor4) }

var fileDescriptor4 = []byte{
	// 268 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x90, 0x31, 0x6f, 0xbb, 0x30,
	0x10, 0xc5, 0xff, 0x0e, 0xfc, 0x49, 0xb8, 0xd0, 0x8a, 0x5e, 0x17, 0x0f, 0x1d, 0x90, 0x27, 0x86,
	0x8a, 0x81, 0x4a, 0xdd, 0xd3, 0x34, 0x95, 0x3a, 0xb4, 0x91, 0x0c, 0x7b, 0x45, 0x89, 0x87, 0xa8,
	0x18, 0x50, 0xb8, 0x0c, 0xfe, 0x66, 0xfd, 0x78, 0x15, 0x36, 0xa8, 0x52, 0x3a, 0xf9, 0xf9, 0xdd,
	0x4f, 0xcf, 0xcf, 0x07, 0x6b, 0x32, 0xbd, 0x1a, 0xb2, 0xfe, 0xd4, 0x51, 0x87, 0xab, 0x93, 0x3a,
	0xd4, 0x4d, 0x77, 0x3e, 0x88, 0x25, 0xfc, 0xdf, 0xe9, 0x9e, 0x8c, 0xf8, 0x66, 0x10, 0x6c, 0xbb,
	0xe6, 0xac, 0x5b, 0x7c, 0x04, 0x7f, 0x84, 0x39, 0x4b, 0x58, 0x7a, 0x9d, 0x8b, 0x6c, 0x86, 0x33,
	0x37, 0x9f, 0x8e, 0x6d, 0xd7, 0x92, 0x6a, 0xa9, 0x34, 0xbd, 0x92, 0x96, 0xc7, 0x3b, 0x08, 0xe9,
	0xa8, 0xd5, 0x40, 0x95, 0xee, 0xf9, 0x22, 0x61, 0xa9, 0x27, 0x7f, 0x0d, 0x8c, 0xc1, 0x23, 0x6a,
	0xb8, 0x67, 0xfd, 0x51, 0x22, 0x87, 0x65, 0xed, 0x42, 0xb8, 0x9f, 0xb0, 0x34, 0x92, 0xf3, 0x55,
	0xdc, 0xc3, 0xcd, 0x9f, 0x47, 0x70, 0x05, 0xfe, 0xf3, 0xa6, 0xdc, 0xc4, 0xff, 0xf0, 0x0a, 0xc2,
	0x72, 0xff, 0xf6, 0x54, 0x94, 0xfb, 0xf7, 0x5d, 0xcc, 0xc4, 0x2b, 0x84, 0x8e, 0x2e, 0x14, 0x21,
	0x82, 0xdf, 0x56, 0xda, 0x95, 0x0f, 0xa5, 0xd5, 0x98, 0x42, 0x50, 0x5b, 0x80, 0x2f, 0x12, 0x2f,
	0x5d, 0xe7, 0xf1, 0xe5, 0x97, 0xe4, 0x34, 0x17, 0x25, 0x44, 0xce, 0x79, 0xa9, 0xf4, 0xb1, 0x31,
	0x63, 0xe9, 0x2f, 0x65, 0x6c, 0x58, 0x24, 0x47, 0x89, 0x39, 0x80, 0x63, 0x3f, 0x06, 0x45, 0x53,
	0xde, 0xed, 0x65, 0x5e, 0xa1, 0x48, 0x86, 0xf5, 0x2c, 0x3f, 0x03, 0xbb, 0xf5, 0x87, 0x9f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x5d, 0x29, 0x13, 0x0f, 0x84, 0x01, 0x00, 0x00,
}
